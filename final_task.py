#Умова
#Індіана Джонс та перстень Цзунь-Си

"""На одному східному ринку до рук Індіани Джонса потрапив цікавий документ. У ньому згадувався загадковий перстень, який належав славетному військовому стратегу стародавності Цзунь-Си і, за словами автора, деяким чином увібрав частку його мудрості. Ймовірно, далі перстень передавався від одного імператора Китаю до іншого і врешті-решт був похований разом з одним із них. 

Для того, щоб перевірити цю інформацію, необхідно навідатися в імператорські усипальні, які являють собою лабіринт з кімнат і переходів. Влада Китаю не дозволяє проводити там жодних досліджень. Але через знайомого в міністерстві культури доктор Джонс отримав дозвіл на запуск робота-дослідника для пошуку артефакта.

  

Вам необхідно скласти функцію maze_controller() для керування роботом. Відомо, що лабіринт є квадратним, десь в ньому має знаходитися перстень Цзунь-Си і все. План лабіринту та його точні розміри, як і точне місцезнаходження входу та шуканого артефакту, невідомі.

На жаль, замість новітнього ВОЛЛІ-3000 доктору Джонсу продали більш дешевий БАЛЛІ-3000, недоліками якого є дуже обмежений радіус дії сенсорів і відсутність вбудованої функції складання карт. Тому наявний робот "бачить" лише те, що знаходиться лише безпосередньо перед ним і визначає наявність перешкод на дорозі лише при безпосередньому контакті з ними.

У робота є об'єктно-орієнтований інтерфейс управління із наступними методами:

    go() -- проїхати на поле вперед, повертає True або False в залежності від того, чи вдалося проїхати (наприклад, перед роботом може знаходитися стіна). Якщо проїхати неможливо, робот залишається на місці.
    turn_left() -- повернути на 90 градусів проти годинникової стрілки.
    turn_right() -- повернути на 90 градусів за годинниковою стрілкою.
    found() -- перевіряє, чи знаходиться перстень у зоні видимості робота.
В якості єдиного аргументу при виклику функції maze_controller() передається ініціалізований об'єкт класу MazeRunner для управління роботом. Функція maze_controller нічого не повертає за допомогою оператора return. Але в результаті її роботи робот має бути переведений у поле лабіринту, в якому знаходиться шуканий артефакт (вважати, що артефакт завжди наявний в лабіринті). Тобто після виклику maze_controller(maze_runner), метод об'єкту maze_runner.found() повинен повертати True. Прямий доступ до зображення лабіринту заборонено.

Приклад класу MazeRunner можна взяти тут.

Приклад послідовності дій для тестування (наступні дії виконуватимуться автоматичним перевіряльником і не повинні міститися в вашому розв'язку):

приклад лабіринту №1 (зовсім простий):

maze_example1 = {
    'm': [
        [0,1,0,0,0],
        [0,1,1,1,1],
        [0,0,0,0,0],
        [1,1,1,1,0],
        [0,0,0,1,0],
    ],
    's': (0,0),
    'f': (4,4)
}
maze_runner = MazeRunner(maze_example1['m'], maze_example1['s'], maze_example1['f']) # ініціалізація робота
maze_controller(maze_runner) # виклик вашої функції
print maze_runner.found()   # перевірка того, що артефакт знайдено, повинно бути True 

приклад лабіринту №2 (простий):

maze_example2 = {
    'm': [
        [0,0,0,0,0,0,0,1],
        [0,1,1,1,1,1,1,1],
        [0,0,0,0,0,0,0,0],
        [1,1,1,1,0,1,0,1],
        [0,0,0,0,0,1,0,1],
        [0,1,0,1,1,1,1,1],
        [1,1,0,0,0,0,0,0],
        [0,0,0,1,1,1,1,0],
    ],
    's': (7,7),
    'f': (0,0)
}
maze_runner = MazeRunner(maze_example2['m'], maze_example2['s'], maze_example2['f'])
maze_controller(maze_runner)
print maze_runner.found()   # True

приклад лабіринту №3 (середньої складності):

maze_example3 = {
    'm': [
        [0,0,0,0,0,0,0,0,0,0,0],
        [1,0,1,1,1,0,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,1,0,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,0,1,0,1],
    ],
    's': (0,5),
    'f': (10,5)
}
maze_runner = MazeRunner(maze_example3['m'], maze_example3['s'], maze_example3['f'])
maze_controller(maze_runner)
print maze_runner.found()   # True

приклад лабіринту №4 (складніший):

maze_example4 = {
    'm': [
        [0,0,0,0,1,0,1,0,0,0,0],
        [0,1,1,1,1,0,1,1,1,1,0],
        [0,0,0,0,0,0,0,0,0,0,0],
        [0,1,0,1,1,1,1,1,0,1,0],
        [1,1,0,1,0,0,0,1,0,1,1],
        [0,1,0,1,0,1,0,1,0,1,0],
        [0,1,0,0,0,1,0,0,0,1,0],
        [0,1,0,1,1,1,1,1,0,1,0],
        [0,1,0,0,0,0,0,0,0,1,0],
        [0,1,1,1,1,0,1,1,1,1,0],
        [0,0,0,0,0,0,0,0,0,0,0],
    ],
    's': (0,5),
    'f': (4,5)
}
maze_runner = MazeRunner(maze_example4['m'], maze_example4['s'], maze_example4['f'])
maze_controller(maze_runner)
print maze_runner.found()   # True

приклад лабіринту №5 (складний):

maze_example5 = {
    'm': [
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,1,0,0,0,0,0,0,0,1,0],
        [0,1,0,1,1,1,1,1,0,1,0],
        [0,0,0,1,0,0,0,1,0,0,0],
        [0,0,1,1,0,0,0,1,1,0,0],
        [0,0,1,0,0,0,0,0,1,0,0],
        [0,0,1,0,1,0,1,0,1,0,0],
        [0,0,1,0,0,0,0,0,1,0,0],
        [0,0,1,1,1,0,1,1,1,0,0],
        [0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,0,1,0,1,0,1,0,0],
    ],
    's': (0,5),
    'f': (4,5)
}
maze_runner = MazeRunner(maze_example5['m'], maze_example5['s'], maze_example5['f'])
maze_controller(maze_runner)
print maze_runner.found()   # True"""

"""І ще раз:

1. Написати функцію maze_controller(mr), єдиним аргументом якої є вже ініціалізований (перевіряльником) об'єкт класу MazeRunner. Функція нічого не повертає, але в результаті її виконання робот має бути переведений в поле лабіринту, де знаходиться артефакт -- тобто після виклику функції maze_controller(maze_runner), метод об'єкту maze_runner.found() повинен повертати True.
2. Прямий доступ до зображення лабіринту заборонено.
3. Ваш розв'язок повинен містити лише функцію maze_controller і нічого крім неї. Жодного введення або виведення даних крім взаємодії з переданим об'єктом бути не повинно. Об'єкт керування роботом створюється та ініціалізується автоматичним перевіряльником поза межами вашої функції.
4. Як завжди, для коректної роботи тестувальника ваш код не повинен містити коментарів, кирилиці, перевірок на те, чи є програма головним модулем, підключення нестандартних модулів, функції exit().
Нагадуємо, що в загальний рейтинг зараховуються бали за останню використану спробу, незалежно від її порядкового номеру."""

def maze_controller(mr):
    while mr.found() != True:
        mr.go()
        if mr.go() == False:
            mr.turn_right()
            mr.go()
            if mr.go() == False:
                mr.turn_left()
                mr.turn_left()
                mr.go()